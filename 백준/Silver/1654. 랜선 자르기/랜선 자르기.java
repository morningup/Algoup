import java.util.Scanner;

public class Main {
    //이분 탐색 문제 : 하지만 다른 이분탐색과 달리 배열의 인덱스를 찾는것이아닌
    //랜선의 길이를 찾는것이 문제(그러므로 랜선을 담는 배열은 정렬되어있지 않아도됨)
    //즉, 배열에서는 원소 값의 비교였다면 랜선 자르기에서는 개수 비교
    //이 문제는 상한을 이용 (이분 탐색의 이용방식 상한,하한 2개)
    /*상한은 찾고자 하는 특정 값을 초과하는 '첫 위치'를 반환한다.
      하한은 찾고자 하는 특정 값 이상인 '첫 위치'를 반환한다.*/
    //ex)arr{1, 2, 2, 2, 3} 이라고 할 때, key 값은 2이고,
    // Upper Bound로 찾는다면 2를 초과되는 처음 위치인 arr[4] = 3 인 index 4가 반환 될 것이다.
    //반대로, Lower Bound로 찾게 된다면 2 이상 위치 중 처음 위치인 arr[1] = 2 인 index 1이 반환 될 것이다.

    //이번 문제는개수가 중복이 될 때 최대 길이를 찾아야 한다는 것이다.
    //쉽게 말해 Upper Bound를 통해 얻어진 값에서 -1을 해주면 최대 길이가 된다. 초과하는 값을 구한다음 그값에 -1
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int K = in.nextInt();
        int N = in.nextInt();

        int[] arr = new int[K];

        long max = 0;

        // 입력과 동시에 해당 랜선의 길이가 최댓값인지를 확인하고 max를 갱신
        for (int i = 0; i < K; i++) { //다른 이분탐색과 달리 정렬하지 않는 이유는
            arr[i] = in.nextInt(); //배열들의 원소가 아닌, 자연수 집합 내에서 탐색하는 것이기에 배열 정렬이 필요가 없기도 하고,
            if(max < arr[i]) {// 최댓값을 찾기위한 목적으로 정렬을 하는 것 외에는 필요가 없다.
                max = arr[i];
            }
        }


        // 반드시 max에서 +1 값이어야 한다.
        //ex)mid가 0이게 되면 그 다음 for문 안에  count += (arr[i] / mid) 부분에서 mid 가 0이라 0으로 나눗셈되는 불상사가 일어나게 된다.
        //이를 위해 해결방법은 입력 받는 랜선에서 최대 길이 + 1 을 max값으로 잡아야한다
        max++;

        long min = 0; // 탐색 길이 최솟값(max를 ++하는것이 이해가 안된다면 min을 1로 설정하여도 무방)
        long mid = 0;

        /*이진 탐색에서 min과 max는 탐색 범위를 나타내는 변수
        이 두 변수는 초기에 주어진 범위의 최솟값과 최댓값으로 설정.
        이진 탐색은 반복적으로 현재의 중간 값을 계산하여 찾고자 하는 값과 비교하고, 그에 따라서 탐색 범위를 좁혀가는 알고리즘입니다.
        min < max 조건은 아직 탐색 범위가 충분히 크다는 의미. 즉, 아직까지 찾고자 하는 값이 현재의 탐색 범위 안에 존재할 가능성이 있는 상태를 나타냄.
        그러므로 이 조건을 만족하는 동안에만 이진 탐색을 계속해서 수행합니다.

        반대로, min >= max인 경우는 더 이상 탐색할 수 있는 범위가 없다는 의미
        즉, 원하는 값이 현재의 탐색 범위 밖에 있거나, 이미 찾아낸 것으로 간주될 때 while문을 종료합니다.
        따라서 while (min < max) 조건은 이진 탐색 알고리즘이 주어진 문제에서 정확하게 동작하기 위해 필요한 반복 조건입니다.
        해당 조건을 통해 계속해서 중간 값을 기준으로 하여 탐색 범위를 좁혀나갈 수 있다.*/
        while (min < max) {//나중가서는 min값과 max값이 한없이 수렴하는 부분이 발생 이 경우 min값의 값이 찾고자하는 최대값이 되므로 while문을 빠져나옴
            //어차피 정수형 정수형 데이터니까 소수점 나오는것들은 버림 즉 그러면 min이 max와 같거나 더 커짐
            // 범위 내에서 중간 길이를 구한다.
            mid = (max + min) / 2;


            long count = 0;

            // 구해진 중간 길이로 잘라서 총 몇 개가 만들어지는지를 구한다.

            for (int i = 0; i < arr.length; i++) {
                count += (arr[i] / mid);
            }

            /*
             *  [upper bound 형식]
             *
             *  mid길이로 잘랐을 때의 개수가 만들고자 하는 랜선의 개수보다 작다면
             *  자르고자 하는 길이를 줄이기 위해 최대 길이를 줄인다.
             *  그 외에는 자르고자 하는 길이를 늘려야 하므로 최소 길이를 늘린다.
             */ //upper bound이므로 해당 구간에서 나오는 값이
            if(count < N) { //현재 개수를 못미친다면 나누는 숫자가 너무 크다는뜻 중간값으로 줄여준다
                max = mid;
            }
            else {
                min = mid + 1;// 현재 개수를 만족하거나 더 큰 경우를 의미
                //같은 경우 : 이제 숫자는 맞추었으므로 더 큰값을 찾기위해 1씩 더하면서 해당 분할되는 개수중에 가장 큰값을 노림
                //더 큰경우 : 해당범위에 있는 mid값이 너무 작은것이므로 더 mid값을 만들기 위해 min에 mid+1값을 넣음(탐색범위 조정)
            }


        }

        // UpperBound로 얻어진 값(min)에 -1이 최대 길이가 된다.
        System.out.println(min - 1);
    }
}